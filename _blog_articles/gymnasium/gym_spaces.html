---
title: Gymnasium - Spaces
desc: This article is the first of a three-part series that focuses on the core components of the Gymnasium library, covering spaces.
img_url: rl-gym-spaces.png
date: 01/12/2022
tag: rl
topic: gymnasium
type: article
permalink: /blog/gymnasium/:title
layout: single-page
---
<p>This article is the first of a three-part series that focuses on the core components of the Gymnasium library. <a href="https://farama.org/projects">Gymnasium</a> is a Python library developed and maintained by <a href="https://openai.com">OpenAI</a>, where its purpose is to house a rich collection of environments for Reinforcement Learning (RL) experiments using a unified interface.</p>
<p>If you have only just started your journey with the Gymnasium framework, the official Gymnasium <a href="https://gymnasium.farama.org/">documentation</a> is a great place to start. However, the information it offers is limited. The articles in this series aim to expand this information and provide a deeper understanding of each of the four components Gymnasium offers. In this article, we focus on <span class="med">Spaces</span>.</p>

<h2>Spaces</h2>
{%- include single_parts/image.html url="spaces-class-hierarchy.png" alt="Spaces class hierarchy" label="Figure 1.1 Spaces class hierarchy." -%}

<p>Spaces assist in defining different types of environment storage spaces within an RL environment, specifically for the observation and action spaces. Six main types derive from the <code>Space(shape=None, dtype=None)</code> abstract class: <code>Discrete</code>, <code>Box</code>, <code>Dict</code>, <code>Tuple</code>, <code>MultiBinary</code>, and <code>MultiDiscrete</code>. However, all spaces are found on the <a href="https://github.com/Farama-Foundation/Gymnasium/tree/main/gymnasium/spaces">Gymnasium GitHub repository</a>. The <code>Space</code> abstract class can be inherited from directly. Though, it is highly recommended to use one of the six primary existing space classes. Furthermore, the space folder contains a file dedicated to utility functions that will also be discussed.</p>
<p>There are four main functions that the <code>Space</code> class provides:</p>
<ul>
    <li><code>sample()</code> - randomly samples an element from the space and returns it.</li>
    <li><code>contains(x)</code> - returns true or false depending on if <code>x</code> is an item within the space.</li>
    <li><code>to_jsonable(sample_n)</code> - converts a given batch (list) of samples into a JSON data type.</li>
    <li><code>from_jsonable(sample_n)</code> - converts a given batch (list) of JSON data into a batch of samples for the space.</li>
</ul>
<p>Every child class that derives from <code>Space</code> creates a version of these four functions that are accessible in the same manner, with the same parameters. However, the <code>Discrete</code> class is the only exception to this, where it uses only two of the four functions: <code>sample()</code> and <code>contains(x)</code>.</p>
<p>Additionally, there are two parameters required for the <code>Space</code> class:</p>
<ul>
    <li><code>shape</code> - a tuple of the size of the space.</li>
    <li><code>dtype</code> - the format type of the data, such as float32 or int32.</li>
</ul>

<h3>Discrete</h3>
<p>The <code>Discrete</code> class represents a mutually exclusive set of items, numbered from 0 to \(n - 1\), where n is the number of items stored within it. For example, <code>Discrete(n=4)</code> could signify an action space with four directions to move in <code>[left, right, up, down]</code>, each is associated with a number between 0 and 3, respectively. A simple code example:</p>

<pre rel="python"><code><span class="keyword">import</span> gymnasium <span class="keyword">as</span> gym

env = gym.make(<span class="string">"FrozenLake-v0"</span>)
<span class="keyword">print</span>(env.action_space) 
<span class="comment"># > Discrete(4)</span>
<span class="keyword">print</span>(env.action_space.<span class="function">sample</span>()) 
<span class="comment"># > 2</span></code></pre>

<h3>Box</h3>
<p>The <code>Box</code> class represents an \(n\)-dimensional tensor of rational numbers with the intervals <code>[low, high]</code>. For instance, this could be an accelerator pedal with a single value between 0 and 1, presented as <code>Box(low=0.0, high=1.0, shape=(1,), dtype=np.float32)</code>, creating a one-dimensional tensor with a single float value.</p>
<p>Another example of <code>Box</code> could represent an Atari screen observation space, which is an RGB (red, green, blue) image of size 210x160: <code>Box(low=0, high=255, shape(210, 160, 3), dtype=np.uint8)</code>. In this instance, we have a tuple with three arguments stating the height, width, and colour channels (red, green, blue), respectively. Overall, every observation consists of a three-dimensional tensor with 100,800 bytes.</p>
<p>These examples present an identical bound <code>Box</code> for each dimension. However, there is another common use case available for independent bound boxes, such as, <code>Box(low=np.array([-1.0, -2.0]), high=np.array([2.0, 4.0]), dtype=np.float32)</code>, where the shape is inferred from the low and high parameters.</p>
<p>The class has one additional function:</p>
<ul>
    <li><code>is_bounded(manner)</code> - accepts the parameters <code>below</code>, <code>above</code>, or <code>both</code> and determines if the <code>Box</code> contains values within the range <code>[-inf, +inf]</code>. If the parameter is below, it will check if <code>-inf</code> is greater than all low numbers, above performs the opposite for all high numbers, and both checks for both comparisons. The function returns true or false based on the conditions.</li>
</ul>
<p>Code example for identical and independent bound boxes:</p>

<pre rel="python"><code><span class="keyword">import</span> numpy <span class="keyword">as</span> np

b1 = <span class="class">Box</span>(low=<span class="number">0.0</span>, high=<span class="number">1.0</span>, shape=(<span class="number">1</span>,), dtype=<span class="class">np</span>.<span class="class">float32</span>) <span class="comment"># identical</span>
b2 = <span class="class">Box</span>(low=<span class="class">np</span>.<span class="class">array</span>([<span class="number">-1.0</span>, <span class="number">2.0</span>]), high=<span class="class">np</span>.<span class="class">array</span>([<span class="number">-2.0</span>, <span class="number">4.0</span>]), dtype=<span class="class">np</span>.<span class="class">float32</span>) <span class="comment"># independent</span>
<span class="keyword">print</span>(b1) 
<span class="comment"># > Box(0.0, 1.0, (1,), float32)</span>
<span class="keyword">print</span>(b2) 
<span class="comment"># > Box(-1.0, 4.0, (2,), float32) - low.min(), high.max(), shape, dtype</span>
<span class="keyword">print</span>(b2.<span class="function">sample</span>()) 
<span class="comment"># > [-1.58, 2.52]</span></code></pre>

<h3>Dict</h3>
<p>The <code>Dict</code> class is the first of two methods that provides a way to store multiple <code>Space</code> class instances in a container, providing the ability to index spaces by a given key, making it easy to categorize and find space objects efficiently.</p>
<p>For example, a simple <code>Dict</code> class that reflects a 2D shape with an x-y position and an x-y-z velocity is created as follows:</p>

<pre rel="python"><code><span class="class">Dict</span>({
    <span class="string">"position"</span>: <span class="class">Discrete</span>(<span class="number">2</span>), 
    <span class="string">"velocity"</span>: <span class="class">Discrete</span>(<span class="number">3</span>)
})</code></pre>

<p>One powerful feature of the <code>Dict</code> class is that we can nest a <code>Dict</code> inside another <code>Dict</code> to make more comprehensive storage containers for large projects. For example:</p>

<pre rel="python"><code><span class="class">Dict</span>({
    <span class="string">'sensors'</span>:  <span class="class">Dict</span>({
        <span class="string">'front_cam'</span>: <span class="class">Tuple</span>((
        <span class="class">Box</span>(low=<span class="number">0</span>, high=<span class="number">1</span>, shape=(<span class="number">10</span>, <span class="number">10</span>, <span class="number">3</span>)),
        <span class="class">Box</span>(low=<span class="number">0</span>, high=<span class="number">1</span>, shape=(<span class="number">10</span>, <span class="number">10</span>, <span class="number">3</span>))
        )),
        <span class="string">'rear_cam'</span>: <span class="class">Box</span>(low=<span class="number">0</span>, high=<span class="number">1</span>, shape=(<span class="number">10</span>, <span class="number">10</span>, <span class="number">3</span>))
    }),
    <span class="string">'ext_controller'</span>: <span class="class">MultiDiscrete</span>((<span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>))
})</code></pre>


<h3>Tuple</h3>
<p>The <code>Tuple</code> class is the second method for storing several <code>Space</code> class instances inside a single container, providing a more minimised storage container.</p> 
<p>Imagine we are creating an environment for a car. The car requires a continuous action space for three components: steering wheel controls, brake pedal positions, and accelerator pedal positions. Additionally, the car needs two sets of discrete action spaces: a turn signal (off, right, or left) and a horn (on or off).</p>
<p>These controls can be represented in the form of a <code>Tuple</code> class as follows:</p>
<pre rel="python"><code>spaces = <span class="class">Box</span>(low=-<span class="number">1.0</span>, high=<span class="number">1.0</span>, shape=(<span class="number">3</span>,), dtype=<span class="class">np</span>.<span class="class">float32</span>)
<span class="class">Tuple</span>(spaces=(spaces, <span class="class">Discrete</span>(n=<span class="number">3</span>), <span class="class">Discrete</span>(n=<span class="number">2</span>)))</code></pre>


<h3>MultiBinary</h3>
<p>The <code>MultiBinary</code> class represents an \(n\)-dimensional binary space containing 0s and 1s. <code>MultiBinary</code> accepts one parameter, \(n\), which is the number of items to add to the binary space. n can be a single number, a list of numbers, or a tuple of numbers.</p>
<p>For example:</p>
<pre rel="python"><code>mb1 = <span class="class">MultiBinary</span>(<span class="number">5</span>)
mb2 = <span class="class">MultiBinary</span>([<span class="number">3</span>, <span class="number">2</span>])
<span class="keyword">print</span>(mb1.<span class="function">sample</span>()) 
<span class="comment"># > array([0, 1, 0, 1, 0], dtype=int8)</span>
<span class="keyword">print</span>(mb2.<span class="function">sample</span>()) 
<span class="comment"># > array([[0, 0], [0, 1], [1, 1]], dtype=int8)</span></code></pre>

<h3>MultiDiscrete</h3>
<p>The <code>MultiDiscrete</code> class creates a series of discrete spaces with a different number of elements in each. A use for this class involves game controllers or keyboards, requiring their own unique discrete action space.</p>
<p>The class accepts two parameters:</p>
<ul>
<li><code>nvec</code> - a list of numbers describing the number of actions in each discrete space.</li>
<li><code>dtype</code> - the format data type of the discrete spaces, defaults to int64.</li>
</ul>
<p>For example, we can conceptualize a Nintendo Game Controller that has three discrete action spaces, where NOOP stands for no operation:</p>
<ol>
<li>Arrow keys (5 actions) - NOOP[0], UP[1], RIGHT[2], DOWN[3], LEFT[4] - min: 0, max: 4.</li>
<li>Button A (2 actions) - NOOP[0], PRESSED[1] - min: 0, max: 1.</li>
<li>Button B (2 actions) - NOOP[0], PRESSED[1] - min: 0, max: 1.</li>
</ol>
<p>The controller is initialized using:</p>
<pre rel="python"><code><span class="class">MultiDiscrete</span>(nvec=[<span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>], dtype=<span class="class">np</span>.<span class="class">int64</span>)</code></pre>

<h3>Utility Functions</h3>
<p>Within the spaces folder, there is a file called <span class="med">utils.py</span> that contains four utility functions:</p>
<ul>
    <li><code>flatdim(space)</code> - returns an integer for the number of dimensions a flatten equivalent of the given space would have.</li>
    <li><code>flatten(space, x)</code> - converts a data point <code>x</code> from a given space into a one-dimensional array and returns the 1D array. The function is useful for passing data points from a space into a neural network that accepts only flattened arrays.</li>
    <li><code>unflatten(space, x)</code> - reverses the transformation applied by <code>flatten(space, x)</code> and returns a data point with a structure that matches the space.</li>
    <li><code>flatten_space(space)</code> - converts a given space into a one-dimensional <code>Box</code>, containing the exact number of dimensions specified with <code>flatdim(space)</code>.</li>
</ul>
<p>Each function has its benefits and can be applied to any RL project by importing the file using the following import statement:</p>
<pre rel="python"><code><span class="keyword">import</span> gym.spaces.utils <span class="keyword">as</span> gym_utils</code></pre>

<p>A code example:</p>
<pre rel="python"><code>b = <span class="class">Box</span>(low=<span class="number">0</span>, high=<span class="number">255</span>, shape=(<span class="number">210</span>, <span class="number">160</span>, <span class="number">3</span>), dtype=<span class="class">np</span>.<span class="class">uint8</span>)
b_flat = gym_utils.<span class="function">flatten_space</span>(b) <span class="comment"># Box(0, 255, (100800,), uint8)</span>
b_flat_count = gym_utils.<span class="function">flatdim</span>(b) <span class="comment"># 100800</span>

<span class="keyword">print</span>(b.<span class="function">sample</span>()[<span class="number">0</span>][:<span class="number">2</span>]) 
<span class="comment"># > [[18 200 33], [123 139 28]] - first 2 rows of first item</span>
<span class="keyword">print</span>(b_flat.<span class="function">sample</span>()[:<span class="number">5</span>]) 
<span class="comment"># > [33 53 352 177 102] - first 5 items</span></code></pre>

<h2>References</h2>
<p>Book by Maxim Lapan (2020) - <a href="https://www.packtpub.com/product/deep-reinforcement-learning-hands-on-second-edition/9781838826994">Deep Reinforcement Learning Hands-On, Second Edition</a></p>
<p>Gymnasium Codebase (2022) - <a href="https://github.com/Farama-Foundation/Gymnasium">GitHub</a></p>
